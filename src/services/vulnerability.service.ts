import api from './api'

// ===== TYPE DEFINITIONS =====
export interface Vulnerability {
  id: number
  title: string
  description: string
  severity: string // 'critical' | 'high' | 'medium' | 'low' | 'info'
  cvss_score: number
  cve_id?: string | null
  source: string // 'snyk_sca' | 'snyk_sast' | 'snyk_dast' | 'manual_vapt' | 'asset_scan'
  source_label: string
  asset_id: number
  asset_name: string
  category?: string
  status: string // 'open' | 'in_progress' | 'fixed' | 'accepted' | 'ignored'
  created_at: string
  updated_at: string
  sla_due_date?: string | null
  sla_status?: string
  remediation?: string | null
  affected_component?: string
  assignee_id?: number | null
  duplicate_of_id?: number | null
  is_deleted: boolean
  found_at?: string | null
  // Optional fields that might not always be present
  asset_type?: string
  sub_asset?: string
  project?: string
  assignee?: string
  affected_versions?: string[]
  recommendation?: string
  reference_urls?: string[]
  date_discovered?: string
  date_due?: string
}

export interface VulnerabilityFilter {
  severity?: string | string[]
  source?: string | string[]
  status?: string | string[]
  status_filter?: string | string[]
  category?: string
  asset_id?: number
  asset_name?: string
  date_range?: { start: string; end: string }
  search?: string
}

export interface VulnerabilityListResponse {
  items: Vulnerability[]
  total: number
  skip: number
  limit: number
  has_more: boolean
}

export interface VulnerabilityStats {
  open_vulnerabilities: { total: number; new_7d: number; trend: number }
  critical_severity: { count: number; overdue: number }
  sla_breached: { count: number; at_risk: number; on_time: number }
  mttr: { days: number; trend: number }
}

export interface VulnerabilityTrend {
  date: string
  critical: number
  high: number
  medium: number
  low: number
}

export interface SeverityBreakdown {
  critical: number
  high: number
  medium: number
  low: number
  info: number
}

export interface StatusBreakdown {
  open: number
  in_progress: number
  fixed: number
  accepted: number
}

// ===== SERVICE CLASS =====
class VulnerabilityService {
  async getStats(): Promise<VulnerabilityStats> {
    try {
      const response = await api.get<VulnerabilityStats>('/api/vulnerabilities/stats')
      return response.data
    } catch (error: any) {
      console.error('Failed to get vulnerability stats:', error)
      throw error
    }
  }

  async getTrend(days: number = 30): Promise<VulnerabilityTrend[]> {
    try {
      const response = await api.get<VulnerabilityTrend[]>('/api/vulnerabilities/trend', {
        params: { days },
      })
      return response.data
    } catch (error: any) {
      console.error('Failed to get vulnerability trend:', error)
      throw error
    }
  }

  async getSeverityBreakdown(): Promise<SeverityBreakdown> {
    try {
      const response = await api.get<SeverityBreakdown>('/api/vulnerabilities/breakdown/severity')
      return response.data
    } catch (error: any) {
      console.error('Failed to get severity breakdown:', error)
      throw error
    }
  }

  async getStatusBreakdown(): Promise<StatusBreakdown> {
    try {
      const response = await api.get<StatusBreakdown>('/api/vulnerabilities/breakdown/status')
      return response.data
    } catch (error: any) {
      console.error('Failed to get status breakdown:', error)
      throw error
    }
  }

  async getAssetsBreakdown(): Promise<{ assets: Array<{ name: string; count: number }> }> {
    try {
      const response = await api.get('/api/vulnerabilities/breakdown/assets')
      return response.data
    } catch (error: any) {
      console.error('Failed to get assets breakdown:', error)
      throw error
    }
  }

  async getEnvironmentsBreakdown(): Promise<{ [key: string]: number }> {
    try {
      const response = await api.get('/api/vulnerabilities/breakdown/environments')
      return response.data
    } catch (error: any) {
      console.error('Failed to get environments breakdown:', error)
      throw error
    }
  }

  async getSLAStatus() {
    try {
      const response = await api.get('/api/vulnerabilities/sla/status')
      return response.data
    } catch (error: any) {
      console.error('Failed to get SLA status:', error)
      throw error
    }
  }

  async getRemediationQueue(status: string[] = ['open', 'in_progress']) {
    try {
      const response = await api.get<VulnerabilityListResponse>(
        '/api/vulnerabilities/remediation-queue',
        { params: { status: status.join(',') } }
      )
      return response.data
    } catch (error: any) {
      console.error('Failed to get remediation queue:', error)
      throw error
    }
  }

  async getVulnerabilities(
    filters?: VulnerabilityFilter,
    page: number = 1,
    limit: number = 20
  ): Promise<VulnerabilityListResponse> {
    try {
      const skip = (page - 1) * limit
      const response = await api.get<VulnerabilityListResponse>('/api/vulnerabilities', {
        params: {
          skip,
          limit,
          ...filters,
        },
      })
      return response.data
    } catch (error: any) {
      console.error('Failed to get vulnerabilities:', error)
      throw error
    }
  }

  async getVulnerabilitiesBySource(source: string, limit: number = 20) {
    try {
      const response = await api.get<VulnerabilityListResponse>('/api/vulnerabilities', {
        params: { source, limit },
      })
      return response.data
    } catch (error: any) {
      console.error(`Failed to get vulnerabilities from source ${source}:`, error)
      throw error
    }
  }

  async getVulnerabilitiesByAsset(assetId: number) {
    try {
      const response = await api.get<VulnerabilityListResponse>('/api/vulnerabilities', {
        params: { asset_id: assetId },
      })
      return response.data
    } catch (error: any) {
      console.error(`Failed to get vulnerabilities for asset ${assetId}:`, error)
      throw error
    }
  }

  async getVulnerabilityDetail(vulnerabilityId: string) {
    try {
      const response = await api.get<Vulnerability>(`/api/vulnerabilities/${vulnerabilityId}`)
      return response.data
    } catch (error: any) {
      console.error(`Failed to get vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async updateVulnerability(vulnerabilityId: string, updates: Partial<Vulnerability>) {
    try {
      const response = await api.patch<Vulnerability>(
        `/api/vulnerabilities/${vulnerabilityId}`,
        updates
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to update vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async bulkUpdateVulnerabilities(
    vulnerabilityIds: string[],
    updates: Partial<Vulnerability>
  ) {
    try {
      const response = await api.post('/api/vulnerabilities/bulk-update', {
        ids: vulnerabilityIds,
        updates,
      })
      return response.data
    } catch (error: any) {
      console.error('Failed to bulk update vulnerabilities:', error)
      throw error
    }
  }

  // ===== ACTION METHODS =====

  async assignVulnerability(
    vulnerabilityId: string,
    assigneeId: number,
    reason?: string
  ) {
    try {
      const response = await api.post(
        `/api/vulnerabilities/${vulnerabilityId}/assign`,
        { assignee_id: assigneeId, reason }
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to assign vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: string,
    reason?: string,
    acceptedRisk?: string
  ) {
    try {
      const response = await api.post(
        `/api/vulnerabilities/${vulnerabilityId}/status`,
        { status, reason, accepted_risk: acceptedRisk }
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to update vulnerability status ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async addComment(
    vulnerabilityId: string,
    text: string,
    isSensitive: boolean = false
  ) {
    try {
      const response = await api.post(
        `/api/vulnerabilities/${vulnerabilityId}/comment`,
        { text, is_sensitive: isSensitive }
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to add comment to vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async getComments(vulnerabilityId: string) {
    try {
      const response = await api.get(
        `/api/vulnerabilities/${vulnerabilityId}/comments`
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to get comments for vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async snoozeVulnerability(
    vulnerabilityId: string,
    snoozeUntil: string,
    reason?: string
  ) {
    try {
      const response = await api.post(
        `/api/vulnerabilities/${vulnerabilityId}/snooze`,
        { snooze_until: snoozeUntil, reason }
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to snooze vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async escalateVulnerability(
    vulnerabilityId: string,
    escalationLevel: number,
    reason: string,
    assignTo?: number
  ) {
    try {
      const response = await api.post(
        `/api/vulnerabilities/${vulnerabilityId}/escalate`,
        { escalation_level: escalationLevel, reason, assign_to: assignTo }
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to escalate vulnerability ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async markFalsePositive(
    vulnerabilityId: string,
    reason: string,
    verifiedBy?: string
  ) {
    try {
      const response = await api.post(
        `/api/vulnerabilities/${vulnerabilityId}/false-positive`,
        { reason, verified_by: verifiedBy }
      )
      return response.data
    } catch (error: any) {
      console.error(`Failed to mark vulnerability as false positive ${vulnerabilityId}:`, error)
      throw error
    }
  }

  async getSourceCounts(filters?: VulnerabilityFilter) {
    try {
      // Get total count with current filters
      const response = await api.get<VulnerabilityListResponse>('/api/vulnerabilities', {
        params: {
          skip: 0,
          limit: 1,
          ...filters,
        },
      })
      
      const total = response.data.total || 0
      
      // Fetch all items to calculate exact source counts
      if (total <= 1000) {
        const allResponse = await api.get<VulnerabilityListResponse>('/api/vulnerabilities', {
          params: {
            skip: 0,
            limit: 1000,
            ...filters,
          },
        })
        
        const allVulns = allResponse.data.items || []
        return {
          all: allResponse.data.total || allVulns.length,
          snyk_sca: allVulns.filter((v: any) => v.source === 'snyk_sca').length,
          snyk_sast: allVulns.filter((v: any) => v.source === 'snyk_sast').length,
          snyk_dast: allVulns.filter((v: any) => v.source === 'snyk_dast').length,
          manual_vapt: allVulns.filter((v: any) => v.source === 'manual_vapt').length,
          asset_scan: allVulns.filter((v: any) => v.source === 'asset_scan').length,
        }
      } else {
        const allResponse = await api.get<VulnerabilityListResponse>('/api/vulnerabilities', {
          params: {
            skip: 0,
            limit: 1000,
            ...filters,
          },
        })
        
        const allVulns = allResponse.data.items || []
        return {
          all: total,
          snyk_sca: allVulns.filter((v: any) => v.source === 'snyk_sca').length,
          snyk_sast: allVulns.filter((v: any) => v.source === 'snyk_sast').length,
          snyk_dast: allVulns.filter((v: any) => v.source === 'snyk_dast').length,
          manual_vapt: allVulns.filter((v: any) => v.source === 'manual_vapt').length,
          asset_scan: allVulns.filter((v: any) => v.source === 'asset_scan').length,
        }
      }
    } catch (error: any) {
      console.error('Failed to get source counts:', error)
      throw error
    }
  }
}

export default new VulnerabilityService()